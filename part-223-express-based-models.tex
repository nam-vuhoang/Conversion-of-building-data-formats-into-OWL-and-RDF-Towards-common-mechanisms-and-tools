\subsubsection{EXPRESS-based data models}\label{sec:express-based-data-models}

\noindent\textbf{Data schemas}

An EXPRESS-based data model is specified with one or more interrelated schemas.
A schema is a unit or module within the whole EXPRESS model that addresses a specific subdomain of the model and may import another schema of the same model.
A schema consists of different kinds of declarations (see Listing \ref{lst:express-schema-declarations}).
% However, the import and constant declarations are currently unused in the IFC-EXPRESS data schemas.
However, as mentioned in \autoref{sec:scope-of-interest} functions (defined with keyword \texttt{FUNCTION}), procedures (\texttt{PROCEDURE}), global rules (\texttt{RULE}), as well as types constraints (\texttt{WHERE}) and derived attributes (\texttt{DERIVE}) are out of consideration.
Data type declarations (\texttt{TYPE} and \texttt{ENTITY}) \textit{without} constraints and derived attributes are discussed below.

\begin{lstlisting}[caption={The structure of an EXPRESS schema.},label=lst:express-schema-declarations]
SCHEMA IFC4;
  [import declarations]
  [constant declarations]
  [type declarations]
  [function declarations]
  [procedure declarations]
  [rule declarations]
SCHEMA;
\end{lstlisting}




There are six groups of data types in EXPRESS, namely \emph{simple} (\emph{primitive})\footnote{
    To avoid confusion between \emph{EXPRESS simple types}, which are built-in primitive types, and \emph{XSD simple types}, which can be built-in primitive, built-in derived, enumeration, or other types, in this paper EXPRESS simple types are called as \emph{primitive types}.
}, \emph{entity}, \emph{enumeration}, \emph{select}, \emph{aggregation}, and \emph{defined}.

% 
% Simple data types
% 
\emph{Primitive data types} are seven built-in types, including \texttt{IN\-TE\-GER}, \texttt{REAL}, \texttt{NUM\-BER}, \texttt{STRING}, \texttt{BI\-NA\-RY}, \texttt{BOOL\-EAN}, and \texttt{LOG\-I\-CAL}.

EXPRESS \texttt{INTEGER} and \texttt{REAL} values can have in principle any length and accuracy, but most implementations restricted them to signed 32-bit integers
% (equivalent to XSD type \texttt{xs:int})
and floating point doubles.
% (\texttt{xs:double}).
Type \texttt{NUM\-BER} is a super type of \texttt{IN\-TE\-GER} and \texttt{REAL}.

\texttt{STRING} values are finite-length sequences of Unicode (ISO/IEC 10646) characters.
\texttt{BINARY} values are arrays of bits.
Types \texttt{STRING} and \texttt{BINARY} can be specified together with maximum size (see \autoref{lst:express-primitive-types}).
By default, \texttt{STRING} can have any length, \texttt{BINARY} is limited to 32 bit.

\begin{lstlisting}[caption={Examples of \texttt{STRING} and \texttt{BINARY} types with maximum size.},label=lst:express-primitive-types]
TYPE IfcGloballyUniqueId = STRING(22) FIXED;
END_TYPE;

TYPE IfcIdentifier = STRING(255);
END_TYPE;

ENTITY IfcPixelTexture
  ...
  Pixel : LIST [1:?] OF BINARY(32);
END_ENTITY;
\end{lstlisting}



Type \texttt{BOOL\-EAN} with two fixed values \texttt{TRUE} and \texttt{FALSE} is used for traditional Boolean (two-valued) logic.
Type \texttt{LOG\-I\-CAL} has three predefined values: \texttt{TRUE},  \texttt{FALSE}, and \texttt{UNKNOWN}, and it is needed for trivalent (three-valued) logics (3VL).
It is worth mentioning that there many 3VLs \cite{fronthofer2011manyvaluedlogics}, which have different numerical representations for the set of truth values \{\texttt{FALSE}, \texttt{UNKNOWN}, \texttt{TRUE}\}, for instance, \{-1, 0, +1\} (Kleene and Priest logics), \{-1, 0, 0/1\} (redundant binary representation), \{0, 1, 2\} (ternary numeral system), and so on.
In contrast, set \{\texttt{FALSE}, \texttt{TRUE}\} in Boolean algebra is always equivalent to \{0, 1\}.
Therefore, it is not recommended to convert interrelated types \texttt{BOOLEAN} and \texttt{LOGICAL} to number types like in \CPP{} programming language.


\emph{Enumeration data types} represent fixed sets of possible string values.
Different enumeration types may have similar values, for instance, both types \texttt{IfcAddressTypeEnum} and \texttt{IfcColumnTypeEnum} have value \texttt{USERDEFINED} (see \autoref{lst:express-enum-types}).


\begin{lstlisting}[caption={Printout of enumeration types \texttt{IfcAddressTypeEnum} and \texttt{IfcColumnTypeEnum}.},label=lst:express-enum-types]
TYPE IfcAddressTypeEnum = ENUMERATION OF
  ( OFFICE, SITE, HOME, DISTRIBUTIONPOINT, USERDEFINED );
END_TYPE;

TYPE IfcColumnTypeEnum = ENUMERATION OF
  ( COLUMN, PILASTER, USERDEFINED, NOTDEFINED );
END_TYPE;
\end{lstlisting}


\emph{Select data types} are unions of other data types, usually non-primitive ones.
Underlying data types of a select type can be very different to each other.
For instance, select type \texttt{IfcTrimmingSelect} is union of entity type \texttt{IfcCartesianPoint} and defined type \texttt{IfcParameterValue}.



\begin{lstlisting}[caption={Printout of select type \texttt{IfcTrimmingSelect} and its underlying types.},label=lst:express-select-types]
TYPE IfcTrimmingSelect = SELECT
  ( IfcCartesianPoint, IfcParameterValue );
END_TYPE;

ENTITY IfcCartesianPoint
 SUBTYPE OF (IfcPoint);
   Coordinates : LIST [1:3] OF IfcLengthMeasure;
 DERIVE
    Dim: IfcDimensionCount := HIINDEX(Coordinates);
 WHERE
    CP2Dor3D : HIINDEX(Coordinates) >= 2;
END_ENTITY;

TYPE IfcParameterValue = REAL;
END_TYPE;
\end{lstlisting}



\emph{Aggregation data types} are \emph{unnamed} containers of values of exactly \emph{one} other data type
\footnote{In other data models, aggregation data usually consist of values from different types.}.
In other words, they like collection types in Java or C{\#} programming languages.
There are four types of aggregation: \texttt{ARRAY} (ordered, defined with start and end indexes), \texttt{LIST} (ordered, defined with minimum and maximum cardinalities), \texttt{SET} (unordered, all values are unique), and \texttt{BAG} (unordered, no duplicated values).
However, \texttt{BAG} aggregation types are most likely never used in practice.
\texttt{LIST} and \texttt{SET} aggregations can have unlimited maximum cardinality.



\emph{Defined} or \emph{named} data types are used to \emph{name} and add constraints to another data type.
For instance, type \texttt{Ifc\-Length\-Measure} is defined to assign a meaningful name to the simple type \texttt{REAL} (see \autoref{lst:express-defined-types}).
Type \texttt{Ifc\-Positive\-Length\-Measure} is defined to restrict \texttt{Ifc\-Length\-Measure} to be positive and add a corresponding name.
Types \texttt{Ifc\-Complex\-Number} and \texttt{Ifc\-Compound\-Plane\-Angle\-Measure} are defined to identify unnamed aggregation types and also add some constraints.


\begin{lstlisting}[caption={Printout of several defined data types},label=lst:express-defined-types]
TYPE IfcLengthMeasure = REAL;
END_TYPE;

TYPE IfcPositiveLengthMeasure = IfcLengthMeasure;
 WHERE
   WR1 : SELF > 0.;
END_TYPE;

TYPE IfcComplexNumber = ARRAY [1:2] OF REAL;
END_TYPE;

TYPE IfcCompoundPlaneAngleMeasure = LIST [3:4] OF INTEGER;
 WHERE
    MinutesInRange : ABS(SELF[2]) < 60;
    SecondsInRange : ABS(SELF[3]) < 60;
    MicrosecondsInRange : (SIZEOF(SELF) = 3) OR (ABS(SELF[4]) < 1000000);
    ...
END_TYPE;
\end{lstlisting}

% TYPE IfcBoxAlignment = IfcLabel;
%  WHERE
% 	WR1 : SELF IN ['top-left', 'top-middle', 'top-right', 'middle-left', 'center', 'middle-right', 'bottom-left', 'bottom-middle', 'bottom-right'];
% END_TYPE;

% TYPE IfcLabel = STRING(255);
% END_TYPE;


    










    

     

% 
% Entity data types
% 
\emph{Entity data types} are almost similar to classes in traditional object-oriented programming (OOP) languages, with a few exceptions:
(i) they have no operations (methods);
(ii) they have three kinds of attributes: explicit, derived and inverse;
(iii) they contain rules (\texttt{WHERE}-constraints).
\emph{Explicit attributes}, such as \texttt{IfcCompositeCurve.Segments} 

are normal attributes, values of which must be serialised when data exchanging because they characterise their entities.
Explicit attributes of an entity type can have any data type allowed in the data model.
If the value type of an entity type attribute is another entity type then we can say that there is a directed association relationship between two entity types.

The association relationship in the inverse direction is called \emph{inverse relationship}
Assume that entity \texttt{a} of type \texttt{A} has attribute \texttt{x} which has entity type \texttt{B}.
If value of an entity explicit attribute is another entity \texttt{a.x = b}

then we can say that there is an association relationship between them.
\emph{Inverse attributes} 

\emph{Derived attributes} can be derived from other attributes of the same entity using formulas, which contain functions and mathematical operations.

    
    contain derived attributes and type constraints, which are outside the range of consideration, as explained above;
    (iii) they have inverse attributes, which are similar to inverse properties in OWL (see Section ...).
    
    Like classes in Java and C{\#}, an entity data type has \emph{not more than one} super type.
    However, attribute names of subtypes should not duplicate attribute names of their super types.
    Nevertheless, there is no restrictions between attribute names in unrelated classes (it is important).
    Each attribute has a certain data type, which can belong to any of the six data type groups.
    In addition, the order of attribute declarations inside each entity data type is important because it is used for serialisation in the STEP-File format.
    
    
    
\begin{lstlisting}[caption={Examples of EXPRESS entity types},label=lst:express-entity-types]
ENTITY IfcCompositeCurve
 SUPERTYPE OF (ONEOF
    (IfcCompositeCurveOnSurface))
 SUBTYPE OF (IfcBoundedCurve);
	Segments : LIST [1:?] OF IfcCompositeCurveSegment;
	SelfIntersect : IfcLogical;
 DERIVE
	NSegments : IfcInteger := SIZEOF(Segments);
	ClosedCurve : IfcLogical := Segments[NSegments].Transition <> Discontinuous;
 WHERE
	CurveContinuous : ((NOT ClosedCurve) AND (SIZEOF(QUERY(Temp <* Segments | Temp.Transition = Discontinuous)) = 1))  = 0));
	SameDim : SIZEOF( QUERY( Temp <* Segments | Temp.Dim <> Segments[1].Dim)) = 0;
END_ENTITY;

ENTITY IfcCompositeCurveSegment
 SUPERTYPE OF (ONEOF
    (IfcReparametrisedCompositeCurveSegment))
 SUBTYPE OF (IfcGeometricRepresentationItem);
	Transition : IfcTransitionCode;
	SameSense : IfcBoolean;
	ParentCurve : IfcCurve;
 DERIVE
	Dim : IfcDimensionCount := ParentCurve.Dim;
 INVERSE
	UsingCurves : SET [1:?] OF IfcCompositeCurve FOR Segments;
 WHERE
	ParentIsBoundedCurve : ('IFC4.IFCBOUNDEDCURVE' IN TYPEOF(ParentCurve));
END_ENTITY;
\end{lstlisting}    
    
    
    
    
    
    
% ENTITY IfcContext
%  ABSTRACT SUPERTYPE OF (ONEOF
%     (IfcProject
%     ,IfcProjectLibrary))
%  SUBTYPE OF (IfcObjectDefinition);
% 	ObjectType : OPTIONAL IfcLabel;
% 	LongName : OPTIONAL IfcLabel;
% 	Phase : OPTIONAL IfcLabel;
% 	RepresentationContexts : OPTIONAL SET [1:?] OF IfcRepresentationContext;
% 	UnitsInContext : OPTIONAL IfcUnitAssignment;
%  INVERSE
% 	IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;
% 	Declares : SET [0:?] OF IfcRelDeclares FOR RelatingContext;
% END_ENTITY;


% ENTITY IfcObject
%  ABSTRACT SUPERTYPE OF (ONEOF
%     (IfcActor
%     ,IfcControl
%     ,IfcGroup
%     ,IfcProcess
%     ,IfcProduct
%     ,IfcResource))
%  SUBTYPE OF (IfcObjectDefinition);
% 	ObjectType : OPTIONAL IfcLabel;
%  INVERSE
% 	IsDeclaredBy : SET [0:1] OF IfcRelDefinesByObject FOR RelatedObjects;
% 	Declares : SET [0:?] OF IfcRelDefinesByObject FOR RelatingObject;
% 	IsTypedBy : SET [0:1] OF IfcRelDefinesByType FOR RelatedObjects;
% 	IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;
%  WHERE
% 	UniquePropertySetNames : ((SIZEOF(IsDefinedBy) = 0) OR IfcUniqueDefinitionNames(IsDefinedBy));
% END_ENTITY;

    
    

    

    
    % Each defined data type can be considered as a named subset (or an equivalent set) of another data type.
    % Without going into detail of type constraints, we can say the following things about the defined data types in \ref{lst:express-defined-types}:
    % \texttt{IfcPositiveLengthMeasure} \subseteq \texttt{IfcLengthMeasure} \equiv \texttt{REAL}
    
    
    % Consider the sample types in Listing \ref{lst:express-defined-types}.
    % The defined type \texttt{IfcPositiveLengthMeasure} is a subset of another defined type \texttt{IfcLengthMeasure}, which in turn is equal to the simple type \texttt{REAL}.
    % The defined type \texttt{IfcBoxAlignment} is a subset of another defined type \texttt{IfcLabel}, which represents a subset \texttt{STRING}








% % According to the mapping methodology from IFC-EXPRESS to IFC-XSD, simple data types \texttt{STRING}, \texttt{INTEGER}, \texttt{REAL}, \texttt{NUMBER}, \texttt{BOOLEAN} are mapped to equivalent standard \texttt{XSD} types, namely \texttt{xs:string} (sometimes \texttt{xs:nor\-ma\-li\-zed\-String}), \texttt{xs:in\-te\-ger}, \texttt{xs:dou\-ble} (twice), and \texttt{xs:\-boo\-le\-an}.
% % In the same time simple data types \texttt{LOGICAL} and \texttt{BINARY} are translated into user defined types \texttt{ifc:lo\-gi\-cal} and \texttt{ifc:hex\-Bi\-na\-ry}.


% In the IFC-EXPRESS schema, all data types for calendar and duration values are defined types, not included in EXPRESS (Listing \ref{lst:express-calendar-types}).

% \begin{lstlisting}[caption={Examples of calendar-related data types},label=lst:express-calendar-types]
% TYPE IfcTime = STRING;
% END_TYPE;

% TYPE IfcTimeMeasure = REAL;
% END_TYPE;

% TYPE IfcTimeStamp = INTEGER;
% END_TYPE;


% TYPE IfcDate = STRING;
% END_TYPE;

% TYPE IfcDateTime = STRING;
% END_TYPE;

% TYPE IfcDuration = STRING;
% END_TYPE;



% \end{lstlisting}


% TODO: Add some example of an entity data type


% % <xs:simpleType name="IfcLogical">
% % 		<xs:restriction base="ifc:logical"/>
% % 	</xs:simpleType>
	
% % 	<xs:simpleType name="IfcMassFlowRateMeasure">
% % 		<xs:restriction base="xs:double"/>
% % 	</xs:simpleType>
	
	
% % 	<xs:simpleType name="IfcTime">
% % 		<xs:restriction base="xs:normalizedString"/>
% % 	</xs:simpleType>
% % 	<xs:simpleType name="IfcTimeMeasure">
% % 		<xs:restriction base="xs:double"/>
% % 	</xs:simpleType>
% % 	<xs:simpleType name="IfcTimeStamp">
% % 		<xs:restriction base="xs:long"/>
% % 	</xs:simpleType>
	
	
% % 		<xs:simpleType name="IfcDate">
% % 		<xs:restriction base="xs:normalizedString"/>
% % 	</xs:simpleType>
% % 	<xs:simpleType name="IfcDateTime">
% % 		<xs:restriction base="xs:normalizedString"/>
% % 	</xs:simpleType>











% % EXPRESS defines 


% % According to terminology of EXPRESS, 

% % , which are a bit different to the data models used traditional OOP (object-oriented programming) languages.
% % In particular, an attribute in EXPRESS may have multiple values, similarly to properties in OWL and unlike class attributes in traditional OOP.
% % Another difference is that lists and sets in EXPRESS may have both minimum and maximum cardinalities, again similarly to OWL.
% % ...
% % Tabular and relational data models are related with such terms as tables, rows and columns.
% % And for that reason, spreadsheets also belong to this category.



% % \begin{table}[!th]
% %     \centering
% %     \begin{tabular}{c|c|c|c}
% %         \hline
% %         Group & EXPRESS-bases & XSD-based & Tabular \& relational data \\
% %         \hline
% %         Data schema & IFC-EXPRESS & IFC-XSD & \\
% %         \hline
% %     \end{tabular}
% %     \caption{Caption}
% %     \label{tab:my_label}
% % \end{table}










% % Firstly, 

% % , such as 




% % The SPF-based formats are the data formats 








% % , which, however, have similar properties.
% % They are: SPF, 




